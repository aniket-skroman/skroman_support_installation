// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: complaint.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addDeviceImages = `-- name: AddDeviceImages :one
insert into device_images (
    complaint_info_id,
    device_image
) values (
    $1, $2
) returning id, complaint_info_id, device_image, created_at, updated_at, file_type
`

type AddDeviceImagesParams struct {
	ComplaintInfoID uuid.UUID `json:"complaint_info_id"`
	DeviceImage     string    `json:"device_image"`
}

func (q *Queries) AddDeviceImages(ctx context.Context, arg AddDeviceImagesParams) (DeviceImages, error) {
	row := q.db.QueryRowContext(ctx, addDeviceImages, arg.ComplaintInfoID, arg.DeviceImage)
	var i DeviceImages
	err := row.Scan(
		&i.ID,
		&i.ComplaintInfoID,
		&i.DeviceImage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileType,
	)
	return i, err
}

const complaintStatusByComplaintInfoId = `-- name: ComplaintStatusByComplaintInfoId :one
select status from complaint_info
where id = $1
`

func (q *Queries) ComplaintStatusByComplaintInfoId(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, complaintStatusByComplaintInfoId, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const countAllComplaint = `-- name: CountAllComplaint :one
select 
(
    select count(*) from complaint_info
) as all_complaints,
(
    select count(*) from complaint_info where status = 'INIT'
) as pending_complaints,
(
    select count(*) from complaint_info where status = 'COMPLETE'
) as comleted_complaints,
(
    select count(*) from complaint_info where status = 'ALLOCATE'
) as allocated_complaints
from complaints as c
`

type CountAllComplaintRow struct {
	AllComplaints       int64 `json:"all_complaints"`
	PendingComplaints   int64 `json:"pending_complaints"`
	ComletedComplaints  int64 `json:"comleted_complaints"`
	AllocatedComplaints int64 `json:"allocated_complaints"`
}

func (q *Queries) CountAllComplaint(ctx context.Context) (CountAllComplaintRow, error) {
	row := q.db.QueryRowContext(ctx, countAllComplaint)
	var i CountAllComplaintRow
	err := row.Scan(
		&i.AllComplaints,
		&i.PendingComplaints,
		&i.ComletedComplaints,
		&i.AllocatedComplaints,
	)
	return i, err
}

const countComplaintByClient = `-- name: CountComplaintByClient :one
select count(*)
from complaints as c 
join complaint_info as ci 
on c.id = ci.complaint_id
where c.client_id = $1
`

func (q *Queries) CountComplaintByClient(ctx context.Context, clientID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countComplaintByClient, clientID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countComplaints = `-- name: CountComplaints :execresult
select id, complaint_id, device_id, problem_statement, problem_category, client_available, status, created_at, updated_at, device_type, device_model, client_available_date, client_available_time_slot, complaint_address from complaint_info
where status = $1
`

func (q *Queries) CountComplaints(ctx context.Context, status string) (sql.Result, error) {
	return q.db.ExecContext(ctx, countComplaints, status)
}

const createComplaint = `-- name: CreateComplaint :one
insert into complaints (
    client_id,
    created_by
) values (
    $1,$2
) returning id, client_id, created_by, created_at, updated_at
`

type CreateComplaintParams struct {
	ClientID  string    `json:"client_id"`
	CreatedBy uuid.UUID `json:"created_by"`
}

func (q *Queries) CreateComplaint(ctx context.Context, arg CreateComplaintParams) (Complaints, error) {
	row := q.db.QueryRowContext(ctx, createComplaint, arg.ClientID, arg.CreatedBy)
	var i Complaints
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createComplaintInfo = `-- name: CreateComplaintInfo :one
insert into complaint_info (
    complaint_id,
    device_id,
    device_type,
    device_model,
    problem_statement,
    problem_category,
    client_available,
    client_available_date,
    client_available_time_slot,
    complaint_address,
    status
) values (
    $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11
) returning id, complaint_id, device_id, problem_statement, problem_category, client_available, status, created_at, updated_at, device_type, device_model, client_available_date, client_available_time_slot, complaint_address
`

type CreateComplaintInfoParams struct {
	ComplaintID             uuid.UUID      `json:"complaint_id"`
	DeviceID                string         `json:"device_id"`
	DeviceType              sql.NullString `json:"device_type"`
	DeviceModel             sql.NullString `json:"device_model"`
	ProblemStatement        string         `json:"problem_statement"`
	ProblemCategory         sql.NullString `json:"problem_category"`
	ClientAvailable         time.Time      `json:"client_available"`
	ClientAvailableDate     sql.NullTime   `json:"client_available_date"`
	ClientAvailableTimeSlot sql.NullString `json:"client_available_time_slot"`
	ComplaintAddress        sql.NullString `json:"complaint_address"`
	Status                  string         `json:"status"`
}

func (q *Queries) CreateComplaintInfo(ctx context.Context, arg CreateComplaintInfoParams) (ComplaintInfo, error) {
	row := q.db.QueryRowContext(ctx, createComplaintInfo,
		arg.ComplaintID,
		arg.DeviceID,
		arg.DeviceType,
		arg.DeviceModel,
		arg.ProblemStatement,
		arg.ProblemCategory,
		arg.ClientAvailable,
		arg.ClientAvailableDate,
		arg.ClientAvailableTimeSlot,
		arg.ComplaintAddress,
		arg.Status,
	)
	var i ComplaintInfo
	err := row.Scan(
		&i.ID,
		&i.ComplaintID,
		&i.DeviceID,
		&i.ProblemStatement,
		&i.ProblemCategory,
		&i.ClientAvailable,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeviceType,
		&i.DeviceModel,
		&i.ClientAvailableDate,
		&i.ClientAvailableTimeSlot,
		&i.ComplaintAddress,
	)
	return i, err
}

const deleteComplaintByID = `-- name: DeleteComplaintByID :execresult
delete from complaints
where id = $1
`

func (q *Queries) DeleteComplaintByID(ctx context.Context, id uuid.UUID) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteComplaintByID, id)
}

const deleteComplaintInfoBYId = `-- name: DeleteComplaintInfoBYId :execresult
delete from complaint_info
where complaint_id = $1
`

func (q *Queries) DeleteComplaintInfoBYId(ctx context.Context, complaintID uuid.UUID) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteComplaintInfoBYId, complaintID)
}

const deleteDeviceFiles = `-- name: DeleteDeviceFiles :execresult
delete from device_images
where id = $1
`

func (q *Queries) DeleteDeviceFiles(ctx context.Context, id uuid.UUID) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteDeviceFiles, id)
}

const fetchAllComplaints = `-- name: FetchAllComplaints :many
select id, complaint_id, device_id, problem_statement, problem_category, client_available, status, created_at, updated_at, device_type, device_model, client_available_date, client_available_time_slot, complaint_address from complaint_info
where status =$3
order by created_at desc 
limit $1
offset $2
`

type FetchAllComplaintsParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Status string `json:"status"`
}

func (q *Queries) FetchAllComplaints(ctx context.Context, arg FetchAllComplaintsParams) ([]ComplaintInfo, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllComplaints, arg.Limit, arg.Offset, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ComplaintInfo{}
	for rows.Next() {
		var i ComplaintInfo
		if err := rows.Scan(
			&i.ID,
			&i.ComplaintID,
			&i.DeviceID,
			&i.ProblemStatement,
			&i.ProblemCategory,
			&i.ClientAvailable,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeviceType,
			&i.DeviceModel,
			&i.ClientAvailableDate,
			&i.ClientAvailableTimeSlot,
			&i.ComplaintAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchComplaintByComplaintId = `-- name: FetchComplaintByComplaintId :one
select id, client_id, created_by, created_at, updated_at from complaints
where id = $1
`

func (q *Queries) FetchComplaintByComplaintId(ctx context.Context, id uuid.UUID) (Complaints, error) {
	row := q.db.QueryRowContext(ctx, fetchComplaintByComplaintId, id)
	var i Complaints
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchComplaintDetailByComplaint = `-- name: FetchComplaintDetailByComplaint :one
select c.created_by as created_by,
(case when c.client_id is null then 'NOT AVAILABEL' else c.client_id end) as client,
ci.device_id as device_id,
ci.id as complaint_info_id,
ci.problem_statement as problem_statement,
ci.problem_category as problem_category,
ci.status as complaint_status,
ci.device_model as device_model, ci.device_type as device_type,
ci.created_at as complaint_raised_at, ci.updated_at as last_modified_at,
ci.client_available_date as client_available_date,
ci.client_available_time_slot as client_available_time_slot,
ci.complaint_address
from complaints c
inner join complaint_info ci 
on c.id = ci.complaint_id
where c.id = $1
`

type FetchComplaintDetailByComplaintRow struct {
	CreatedBy               uuid.UUID      `json:"created_by"`
	Client                  interface{}    `json:"client"`
	DeviceID                string         `json:"device_id"`
	ComplaintInfoID         uuid.UUID      `json:"complaint_info_id"`
	ProblemStatement        string         `json:"problem_statement"`
	ProblemCategory         sql.NullString `json:"problem_category"`
	ComplaintStatus         string         `json:"complaint_status"`
	DeviceModel             sql.NullString `json:"device_model"`
	DeviceType              sql.NullString `json:"device_type"`
	ComplaintRaisedAt       time.Time      `json:"complaint_raised_at"`
	LastModifiedAt          time.Time      `json:"last_modified_at"`
	ClientAvailableDate     sql.NullTime   `json:"client_available_date"`
	ClientAvailableTimeSlot sql.NullString `json:"client_available_time_slot"`
	ComplaintAddress        sql.NullString `json:"complaint_address"`
}

func (q *Queries) FetchComplaintDetailByComplaint(ctx context.Context, id uuid.UUID) (FetchComplaintDetailByComplaintRow, error) {
	row := q.db.QueryRowContext(ctx, fetchComplaintDetailByComplaint, id)
	var i FetchComplaintDetailByComplaintRow
	err := row.Scan(
		&i.CreatedBy,
		&i.Client,
		&i.DeviceID,
		&i.ComplaintInfoID,
		&i.ProblemStatement,
		&i.ProblemCategory,
		&i.ComplaintStatus,
		&i.DeviceModel,
		&i.DeviceType,
		&i.ComplaintRaisedAt,
		&i.LastModifiedAt,
		&i.ClientAvailableDate,
		&i.ClientAvailableTimeSlot,
		&i.ComplaintAddress,
	)
	return i, err
}

const fetchComplaintsByClient = `-- name: FetchComplaintsByClient :many
select c.id, client_id, created_by, c.created_at, c.updated_at, ci.id, complaint_id, device_id, problem_statement, problem_category, client_available, status, ci.created_at, ci.updated_at, device_type, device_model, client_available_date, client_available_time_slot, complaint_address
from complaints as c 
join complaint_info as ci 
on c.id = ci.complaint_id
where c.client_id = $1
order by ci.created_at desc 
limit $2
offset $3
`

type FetchComplaintsByClientParams struct {
	ClientID string `json:"client_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type FetchComplaintsByClientRow struct {
	ID                      uuid.UUID      `json:"id"`
	ClientID                string         `json:"client_id"`
	CreatedBy               uuid.UUID      `json:"created_by"`
	CreatedAt               time.Time      `json:"created_at"`
	UpdatedAt               time.Time      `json:"updated_at"`
	ID_2                    uuid.UUID      `json:"id_2"`
	ComplaintID             uuid.UUID      `json:"complaint_id"`
	DeviceID                string         `json:"device_id"`
	ProblemStatement        string         `json:"problem_statement"`
	ProblemCategory         sql.NullString `json:"problem_category"`
	ClientAvailable         time.Time      `json:"client_available"`
	Status                  string         `json:"status"`
	CreatedAt_2             time.Time      `json:"created_at_2"`
	UpdatedAt_2             time.Time      `json:"updated_at_2"`
	DeviceType              sql.NullString `json:"device_type"`
	DeviceModel             sql.NullString `json:"device_model"`
	ClientAvailableDate     sql.NullTime   `json:"client_available_date"`
	ClientAvailableTimeSlot sql.NullString `json:"client_available_time_slot"`
	ComplaintAddress        sql.NullString `json:"complaint_address"`
}

func (q *Queries) FetchComplaintsByClient(ctx context.Context, arg FetchComplaintsByClientParams) ([]FetchComplaintsByClientRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchComplaintsByClient, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchComplaintsByClientRow{}
	for rows.Next() {
		var i FetchComplaintsByClientRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.ComplaintID,
			&i.DeviceID,
			&i.ProblemStatement,
			&i.ProblemCategory,
			&i.ClientAvailable,
			&i.Status,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeviceType,
			&i.DeviceModel,
			&i.ClientAvailableDate,
			&i.ClientAvailableTimeSlot,
			&i.ComplaintAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchCountByMonth = `-- name: FetchCountByMonth :many
with lm as 
(
SELECT
	to_char(d, 'Month') as n_month
FROM
    GENERATE_SERIES(
        now(),
        now() - interval '12 months',
        interval '-1 months'
    ) AS d
)


select  l.n_month as month,
count(distinct ci.id)
from lm as l
left join complaint_info as ci 
on l.n_month = to_char(ci.created_at, 'Month')
group by to_char(ci.created_at, 'Month'),l.n_month
order by l.n_month desc
`

type FetchCountByMonthRow struct {
	Month string `json:"month"`
	Count int64  `json:"count"`
}

func (q *Queries) FetchCountByMonth(ctx context.Context) ([]FetchCountByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchCountByMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchCountByMonthRow{}
	for rows.Next() {
		var i FetchCountByMonthRow
		if err := rows.Scan(&i.Month, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchDeviceFileById = `-- name: FetchDeviceFileById :one
select id, complaint_info_id, device_image, created_at, updated_at, file_type from device_images
where id = $1
`

func (q *Queries) FetchDeviceFileById(ctx context.Context, id uuid.UUID) (DeviceImages, error) {
	row := q.db.QueryRowContext(ctx, fetchDeviceFileById, id)
	var i DeviceImages
	err := row.Scan(
		&i.ID,
		&i.ComplaintInfoID,
		&i.DeviceImage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileType,
	)
	return i, err
}

const fetchDeviceImagesByComplaintId = `-- name: FetchDeviceImagesByComplaintId :many
select id, complaint_info_id, device_image, created_at, updated_at, file_type from device_images
where complaint_info_id = $1
`

func (q *Queries) FetchDeviceImagesByComplaintId(ctx context.Context, complaintInfoID uuid.UUID) ([]DeviceImages, error) {
	rows, err := q.db.QueryContext(ctx, fetchDeviceImagesByComplaintId, complaintInfoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceImages{}
	for rows.Next() {
		var i DeviceImages
		if err := rows.Scan(
			&i.ID,
			&i.ComplaintInfoID,
			&i.DeviceImage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FileType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComplaintInfo = `-- name: UpdateComplaintInfo :one
update complaint_info
set device_id = $2,
device_model=$3,
device_type=$4,
problem_statement=$5,
problem_category=$6,
client_available_date=$7, 
client_available_time_slot=$8,
complaint_address=$9,
updated_at = CURRENT_TIMESTAMP
where id = $1
returning id, complaint_id, device_id, problem_statement, problem_category, client_available, status, created_at, updated_at, device_type, device_model, client_available_date, client_available_time_slot, complaint_address
`

type UpdateComplaintInfoParams struct {
	ID                      uuid.UUID      `json:"id"`
	DeviceID                string         `json:"device_id"`
	DeviceModel             sql.NullString `json:"device_model"`
	DeviceType              sql.NullString `json:"device_type"`
	ProblemStatement        string         `json:"problem_statement"`
	ProblemCategory         sql.NullString `json:"problem_category"`
	ClientAvailableDate     sql.NullTime   `json:"client_available_date"`
	ClientAvailableTimeSlot sql.NullString `json:"client_available_time_slot"`
	ComplaintAddress        sql.NullString `json:"complaint_address"`
}

func (q *Queries) UpdateComplaintInfo(ctx context.Context, arg UpdateComplaintInfoParams) (ComplaintInfo, error) {
	row := q.db.QueryRowContext(ctx, updateComplaintInfo,
		arg.ID,
		arg.DeviceID,
		arg.DeviceModel,
		arg.DeviceType,
		arg.ProblemStatement,
		arg.ProblemCategory,
		arg.ClientAvailableDate,
		arg.ClientAvailableTimeSlot,
		arg.ComplaintAddress,
	)
	var i ComplaintInfo
	err := row.Scan(
		&i.ID,
		&i.ComplaintID,
		&i.DeviceID,
		&i.ProblemStatement,
		&i.ProblemCategory,
		&i.ClientAvailable,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeviceType,
		&i.DeviceModel,
		&i.ClientAvailableDate,
		&i.ClientAvailableTimeSlot,
		&i.ComplaintAddress,
	)
	return i, err
}

const updateComplaintStatus = `-- name: UpdateComplaintStatus :execresult
update complaint_info
set status = $2,
updated_at = CURRENT_TIMESTAMP
where complaint_id = $1
`

type UpdateComplaintStatusParams struct {
	ComplaintID uuid.UUID `json:"complaint_id"`
	Status      string    `json:"status"`
}

func (q *Queries) UpdateComplaintStatus(ctx context.Context, arg UpdateComplaintStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateComplaintStatus, arg.ComplaintID, arg.Status)
}

const uploadDeviceImages = `-- name: UploadDeviceImages :one
insert into device_images(
    complaint_info_id,
    device_image,
    file_type
) values (
    $1, $2, $3
) returning id, complaint_info_id, device_image, created_at, updated_at, file_type
`

type UploadDeviceImagesParams struct {
	ComplaintInfoID uuid.UUID      `json:"complaint_info_id"`
	DeviceImage     string         `json:"device_image"`
	FileType        sql.NullString `json:"file_type"`
}

func (q *Queries) UploadDeviceImages(ctx context.Context, arg UploadDeviceImagesParams) (DeviceImages, error) {
	row := q.db.QueryRowContext(ctx, uploadDeviceImages, arg.ComplaintInfoID, arg.DeviceImage, arg.FileType)
	var i DeviceImages
	err := row.Scan(
		&i.ID,
		&i.ComplaintInfoID,
		&i.DeviceImage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FileType,
	)
	return i, err
}
